(cl:in-package :cl-user)
(defpackage dlfile (:use cl))
(in-package dlfile)

(defconstant +program+ "mk.dlfile.lisp")
(defconstant +source-c+ #p"extern_dlfile.c")
(defconstant +source-h+ #p"extern_dlfile.h")
(defconstant +lispdl-c+ #p"lispdl.c")
(defconstant +lispdl-h+ #p"lispdl.h")

(defparameter *base* '(#p"./" #p"../" #p"../../src/"))

(defparameter +extern-header+
  '(#p"extern_control.h"
    #p"extern_error.h"
    #p"extern_execute.h"
    #p"extern_function.h"
    #p"extern_init.h"
    #p"extern_instance.h"
    #p"extern_object.h"
    #p"extern_print.h"
    #p"extern_sequence.h"
    #p"extern_stream.h"
    #p"extern_type.h"
    #p"extern_unicode.h"))

(defparameter +lisp-header+
  '("define.h"
    "typedef_basic.h"
    "typedef_integer.h"
    "typedef_stream.h"
    "typedef.h"
    "define_setjmp.h"
    "extern_typedef.h"))

(defvar *function* nil)
(defvar *include* nil)


;;
;;  tools
;;
(defmacro dobind (bind expr &body body)
  (let ((g (gensym)))
    `(dolist (,g ,expr)
       (destructuring-bind ,bind ,g
         ,@body))))

(defun make-filename (x)
  (dolist (base *base*)
    (let ((x (merge-pathnames x base)))
      (if (probe-file x)
        (return x)))))

(defun read-line-call (input call)
  (do (x) (nil)
    (setq x (read-line input nil nil))
    (unless x
      (return nil))
    (funcall call x)))

(defun namestring-name-type (file)
  (format nil "~A.~A"
          (pathname-name file)
          (pathname-type file)))

(defun split-whitespace (x)
  (let* ((x (string-trim '(#\Space #\Tab) x))
         (n (position-if
              (lambda (x) (member x '(#\Space #\Tab)))
              x)))
    (if (null n)
      (list x)
      (cons (subseq x 0 n) (split-whitespace (subseq x n))))))


;;
;;  parse-include
;;
(defun parse-include-name (x)
  (let ((size (length x)))
    (when (<= size 2)
      (error "Invalid include name ~S" x))
    (let ((a (char x 0))
          (b (subseq x 1 (1- size)))
          (c (char x (1- size))))
      (unless (member a '(#\< #\"))
        (error "First parensis error ~S" a))
      (unless (member c '(#\> #\"))
        (error "First parensis error ~S" c))
      (values b a))))

(defun parse-include (x)
  (let ((list (split-whitespace x)))
    (if (and (= (length list) 2)
             (equal (car list) "#include"))
      (multiple-value-bind (name split) (parse-include-name (second list))
        (values t name split)))))


;;
;;  header
;;
(defun header-pragma-output (s)
  (format s "#ifdef __clang__~%")
  (format s "#pragma clang diagnostic push~%")
  (format s "#pragma clang diagnostic ignored \"-Wunused-function\"~%")
  (format s "#endif~%")
  (format s "#ifdef __GNUC__~%")
  (format s "#pragma GCC diagnostic push~%")
  (format s "#pragma GCC diagnostic ignored \"-Wunused-function\"~%")
  (format s "#endif~%"))

(defun footer-pragma-output (s)
  (format s "#ifdef __GNUC__~%")
  (format s "#pragma GCC diagnostic pop~%")
  (format s "#endif~%")
  (format s "#ifdef __clang__~%")
  (format s "#pragma clang diagnostic pop~%")
  (format s "#endif~%"))

(defun header-cplusplus-output (s)
  (format s "#ifdef __cplusplus~%")
  (format s "#ifndef __STDC_LIMIT_MACROS~%")
  (format s "#define __STDC_LIMIT_MACROS~%")
  (format s "#endif~%")
  (format s "#ifndef __STDC_CONSTANT_MACROS~%")
  (format s "#define __STDC_CONSTANT_MACROS~%")
  (format s "#endif~%")
  (format s "#endif~%"))


;;
;;  source.c
;;
(defun source-c-body (s)
  (format s "/*  Auto generated by ~A  */~%" +program+)
  (format s "#include \"build.h\"~%")
  (dolist (x *function*)
    (format s "#include \"~A\"~%" (car x)))
  (format s "#include \"extern_dlfile.h\"~2%")
  (format s "#define LispdlSet(ptr, x) (ptr[lispdl_##x] = (void *)x)~%")
  (format s "void lisp_dlfile_make(lisp_dlfile_array ptr)~%")
  (format s "{~%")
  (format s "    /* variables */~%")
  (format s "    ptr[lispdl_nil] = Nil;~%")
  (format s "    ptr[lispdl_t] = T;~%")
  (dolist (x *function*)
    (destructuring-bind (name . list) x
      (format s "~%    /* ~A */~%" name)
      (dolist (y list)
        (unless y
          (error "source-c-body error."))
        (format s "    LispdlSet(ptr, ~A);~%" y))))
  (format s "~%    /* End */~%")
  (format s "    ptr[lispdl_unbound] = Unbound;~%")
  (format s "    ptr[lispdl_end] = NULL;~%")
  (format s "}~%")
  (format s "#undef LispdlSet"))

(defun output-source-file (file)
  (let ((check (merge-pathnames file #p"../")))
    (if (probe-file check)
      check
      file)))

(defun output-source-c ()
  (let ((file (output-source-file +source-c+)))
    (with-open-file (stream file :direction :output
                            :if-exists :supersede
                            :if-does-not-exist :create)
      (source-c-body stream))))


;;
;;  source.h
;;
(defun source-h-header (s)
  (format s "/*  Auto generated by ~A  */~%" +program+)
  (format s "#ifndef __LISP_EXTERN_DLFILE_HEADER__~%")
  (format s "#define __LISP_EXTERN_DLFILE_HEADER__~2%"))

(defun source-h-body (s)
  (format s "enum lisp_dlfile_calltype {~%")
  (format s "    /* variable */~%")
  (format s "    lispdl_nil,~%")
  (format s "    lispdl_t,~%")
  (dolist (x *function*)
    (destructuring-bind (name . list) x
      (format s "~%    /* ~A */~%" name)
      (dolist (y list)
        (unless y
          (error "source-h-body error."))
        (format s "    lispdl_~A,~%" y))))
  (format s "~%    /* End */~%")
  (format s "    lispdl_unbound,~%")
  (format s "    lispdl_end,~%")
  (format s "    lispdl_size~%")
  (format s "};~2%")
  (format s "typedef void *lisp_dlfile_array[lispdl_size];~2%"))

(defun source-h-function (s)
  (format s "void lisp_dlfile_make(lisp_dlfile_array ptr);~2%"))

(defun source-h-footer (s)
  (format s "#endif~%"))

(defun output-source-h ()
  (let ((file (output-source-file +source-h+)))
    (with-open-file (stream file :direction :output
                            :if-exists :supersede
                            :if-does-not-exist :create)
      (source-h-header stream)
      (source-h-body stream)
      (source-h-function stream)
      (source-h-footer stream))))


;;
;;  lispdl.c
;;
(defun lispdl-header (s file)
  (format s "/*~%")
  (format s " *  npt -- ANSI Common Lisp Programming Language.~%")
  (format s " *    https://github.com/nptcl/npt~%")
  (format s " *    https://github.com/nptcl/npt-amalgamation~%")
  (format s " *~%")
  (format s " *  File: ~A~%" (namestring-name-type file))
  (format s " */~%"))

(defun lispdl-c-header (s)
  (lispdl-header s +lispdl-c+)
  (header-pragma-output s)
  (terpri s)
  (header-cplusplus-output s)
  (terpri s)
  (format s "#include \"~A\"~%" +lispdl-h+)
  (format s "#include <stdint.h>~%")
  (terpri s))

(defun lispdl-c-variable (s &optional (prefix ""))
  (format s "/*~%")
  (format s " *  variables~%")
  (format s " */~%")
  (format s "~Aaddr lisp_nil_object;~%" prefix)
  (format s "~Aaddr lisp_t_object;~%" prefix)
  (dolist (x *prototype*)
    (destructuring-bind (name . list) x
      (format s "~%/* ~A */~%" name)
      (dobind (y z) list
        (declare (ignore y))
        (format s "~A~A~%" prefix z))))
  (format s "~%"))

(defun lispdl-make-type (y z)
  (let ((a (search y z)))
    (setq z (format nil "~A~A"
                    (subseq z 0 a)
                    (subseq z (+ (length y) a))))
    (let ((n (position #\; z)))
      (if n
        (subseq z 0 n)
        z))))

(defun lispdl-c-function (s)
  (format s "~%/*~%")
  (format s " * lisp_dlfiles~%")
  (format s " */~%")
  (format s "#define LispdlLet(ptr, x, type) (x = (type)ptr[lispdl_##x])~%")
  (format s "int lisp_dlfile_update(lisp_dlfile_array ptr)~%")
  (format s "{~%")
  (format s "    if (ptr[lispdl_unbound] != (addr)(~~(intptr_t)0))~%")
  (format s "        return 1;~%")
  (format s "    if (ptr[lispdl_end] != NULL)~%")
  (format s "        return 1;~2%")
  (format s "    /* variables */~%")
  (format s "    lisp_nil_object = (addr)ptr[lispdl_nil];~%")
  (format s "    lisp_t_object = (addr)ptr[lispdl_t];~%")
  (dolist (x *prototype*)
    (destructuring-bind (name . list) x
      (format s "~%    /* ~A */~%" name)
      (dobind (y z) list
        (setq z (lispdl-make-type y z))
        (format s "    LispdlLet(ptr, ~A, ~A);~%" y z))))
  (terpri s)
  (format s "    return 0;~%")
  (format s "}~%")
  (format s "#undef LispdlLet~%"))

(defun lispdl-c-footer (s)
  (terpri s)
  (footer-pragma-output s))

(defun output-lispdl-c ()
  (with-open-file (stream +lispdl-c+ :direction :output
                          :if-exists :supersede
                          :if-does-not-exist :create)
    (lispdl-c-header stream)
    (lispdl-c-variable stream)
    (lispdl-c-function stream)
    (lispdl-c-footer stream)))


;;
;;  lispdl.h
;;
(defvar *lispdl-include*)
(defvar *lispdl-source*)

(defun header-first (file)
  (push "" *lispdl-source*)
  (push "" *lispdl-source*)
  (let ((asterisk "************************************************************"))
    (push (format nil "/~A" asterisk) *lispdl-source*)
    (push (format nil " *  ~A" (namestring-name-type file)) *lispdl-source*)
    (push (format nil " ~A/" asterisk) *lispdl-source*)))

(defun lispdl-readonly (x)
  (multiple-value-bind (check name split) (parse-include x)
    (cond ((null check))
          ((eql split #\"))
          ((eql split #\<) (pushnew name *lispdl-include* :test #'equal))
          (t (error "Invalid source, ~S." x)))))

(defun lispdl-make1 ()
  (dolist (x +extern-header+)
    (let ((file (make-filename x)))
      (with-open-file (input file)
        (read-line-call input #'lispdl-readonly)))))

(defun lispdl-redirect (x)
  (multiple-value-bind (check name split) (parse-include x)
    (cond ((null check)
           (push x *lispdl-source*))
          ((eql split #\"))
          ((eql split #\<) (pushnew name *lispdl-include* :test #'equal))
          (t (error "Invalid source, ~S." x)))))

(defun lispdl-make2 ()
  (dolist (x +lisp-header+)
    (let ((file (make-filename x)))
      (with-open-file (input file)
        (header-first file)
        (read-line-call input #'lispdl-redirect)))))

(defun lispdl-make ()
  (lispdl-make1)
  (lispdl-make2))

(defun lispdl-h-source (s)
  (dolist (x *lispdl-source*)
    (format s "~A~%" x)))

(defun lispdl-h-header (s)
  (format s "#ifndef __LISPDL_HEADER__~%")
  (format s "#define __LISPDL_HEADER__~2%")
  (header-cplusplus-output s)
  (terpri s)
  (dolist (x (sort *lispdl-include* #'string<))
    (format s "#include <~A>~%" x)))

(defun lispdl-h-body (s)
  (source-h-body s)
  (terpri s)
  (lispdl-c-variable s "extern ")
  ;;  function
  (format s "/* function */~%")
  (format s "int lisp_dlfile_update(lisp_dlfile_array ptr);~%"))

(defun lispdl-h-footer (s)
  (format s "~%#endif~%"))

(defun output-lispdl-h ()
  (let (*lispdl-include* *lispdl-source*)
    (lispdl-make)
    (setq *lispdl-include* (nreverse *lispdl-include*))
    (setq *lispdl-source* (nreverse *lispdl-source*))
    (with-open-file (stream +lispdl-h+ :direction :output
                            :if-exists :supersede
                            :if-does-not-exist :create)
      (lispdl-header stream +lispdl-h+)
      (lispdl-h-header stream)
      (lispdl-h-source stream)
      (lispdl-h-body stream)
      (lispdl-h-footer stream))))


;;
;;  load
;;
(defun split-callname-p (x)
  (or (char<= #\a x #\z)
      (char<= #\A x #\Z)
      (char<= #\0 x #\9)
      (char= #\_ x)))

(defun split-callname (x a &aux b)
  (setq a (search "lisp" x :test #'equalp :start2 a))
  (unless a
    (error "Invalid callname, ~S." x))
  (setq b (position-if-not #'split-callname-p x :start a))
  (unless b
    (error "Invalid callname, ~S." x))
  (if (char= (char x b) #\Space)
    (split-callname x b)
    (subseq x a b)))

(defun parse-callname (x)
  (let ((a (search "lisp" x :test #'equalp)))
    (unless a
      (error "Invalid callname, ~S." x))
    (unless (search "#define" x)
      (split-callname x 0))))

(defvar *name* nil)
(defvar *prototype* nil)

(defun load-extern-include (x c)
  (let* ((a (search c x))
         (b (+ a (length c))))
    (format nil "~A(*~A)~A"
            (subseq x 0 a)
            c
            (subseq x b))))

(defun load-extern-call (x)
  (let ((a (position #\( x)))
    (when a
      (let ((b (position #\) x)))
        (unless b
          (error "Parensis error, ~S." x))
        (let ((c (parse-callname x)))
          (when c
            (push (list c (load-extern-include x c)) *prototype*)
            (push c *name*)))))))

(defun load-extern-read (file)
  (let ((file (make-filename file))
        *name* *prototype*)
    (with-open-file (input file)
      (read-line-call input #'load-extern-call))
    (values
      (nreverse *name*)
      (nreverse *prototype*))))

(defun load-extern (file)
  (let ((name (namestring-name-type file)))
    (multiple-value-bind (list proto) (load-extern-read file)
      (push (cons name list) *function*)
      (push (cons name proto) *prototype*))))


;;
;;  Main
;;
(dolist (x +extern-header+)
  (load-extern x)
  (unless (eql (length *function*)
               (length *prototype*))
    (error "length error"))
  (setq *function* (nreverse *function*))
  (setq *prototype* (nreverse *prototype*)))

(output-source-c)
(output-source-h)
(output-lispdl-c)
(output-lispdl-h)

